// ignore_for_file: non_constant_identifier_names, camel_case_types, missing_return, unused_import, unused_local_variable
//////////////////////////////////////////////////////////
// GENERATED BY FLUTTIFY. DO NOT EDIT IT.
//////////////////////////////////////////////////////////

import 'dart:typed_data';

import 'package:amap_map_fluttify/src/ios/ios.export.g.dart';
import 'package:amap_map_fluttify/src/android/android.export.g.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';

class com_autonavi_ae_gmap_GLMapRender extends java_lang_Object  {
  static final int NORMAL_TICK_COUNT = 2;
  static final int ANIMATION_TICK_COUNT = 10;
  static final int LONG_TICK_COUNT = 6;
  static final int LONG_LONG_TICK_COUNT = 30;
  static final int RENDER_FPS_NAVI = 10;
  static final int RENDER_FPS_NORMAL = 15;
  static final int RENDER_FPS_ANIMATION = 30;
  static final int RENDER_FPS_GESTURE_ACTION = 40;

  // generate getters
  Future<bool> get_mSurfacedestoryed() async {
    final result = await MethodChannel('me.yohom/amap_map_fluttify').invokeMethod("com.autonavi.ae.gmap.GLMapRender::get_mSurfacedestoryed", {'refId': refId});
  
    return result;
  }
  

  // generate setters
  Future<void> set_mGLMapView(com_autonavi_amap_mapcore_interfaces_IAMap mGLMapView) async {
    await MethodChannel('me.yohom/amap_map_fluttify').invokeMethod('com.autonavi.ae.gmap.GLMapRender::set_mGLMapView', {'refId': refId, "mGLMapView": mGLMapView.refId});
  
    MethodChannel('com.autonavi.amap.mapcore.interfaces.IAMap::Callback')
      .setMethodCallHandler((methodCall) async {
        final args = methodCall.arguments as Map;
        // final refId = args['callerRefId'] as int;
        // if (refId != this.refId) return;
  
        switch (methodCall.method) {
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getCameraPosition':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getCameraPosition([])');
            }
        
            // handle the native call
            mGLMapView?.getCameraPosition();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getMaxZoomLevel':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getMaxZoomLevel([])');
            }
        
            // handle the native call
            mGLMapView?.getMaxZoomLevel();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getMinZoomLevel':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getMinZoomLevel([])');
            }
        
            // handle the native call
            mGLMapView?.getMinZoomLevel();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::moveCamera':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: moveCamera([])');
            }
        
            // handle the native call
            mGLMapView?.moveCamera(com_amap_api_maps_CameraUpdate()..refId = (args['var1'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::animateCamera':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: animateCamera([])');
            }
        
            // handle the native call
            mGLMapView?.animateCamera(com_amap_api_maps_CameraUpdate()..refId = (args['var1'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::stopAnimation':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: stopAnimation([])');
            }
        
            // handle the native call
            mGLMapView?.stopAnimation();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::addNavigateArrow':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: addNavigateArrow([])');
            }
        
            // handle the native call
            mGLMapView?.addNavigateArrow(com_amap_api_maps_model_NavigateArrowOptions()..refId = (args['var1'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::addPolyline':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: addPolyline([])');
            }
        
            // handle the native call
            mGLMapView?.addPolyline(com_amap_api_maps_model_PolylineOptions()..refId = (args['var1'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::addCircle':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: addCircle([])');
            }
        
            // handle the native call
            mGLMapView?.addCircle(com_amap_api_maps_model_CircleOptions()..refId = (args['var1'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::addArc':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: addArc([])');
            }
        
            // handle the native call
            mGLMapView?.addArc(com_amap_api_maps_model_ArcOptions()..refId = (args['var1'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::addPolygon':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: addPolygon([])');
            }
        
            // handle the native call
            mGLMapView?.addPolygon(com_amap_api_maps_model_PolygonOptions()..refId = (args['var1'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::addGroundOverlay':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: addGroundOverlay([])');
            }
        
            // handle the native call
            mGLMapView?.addGroundOverlay(com_amap_api_maps_model_GroundOverlayOptions()..refId = (args['var1'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::addMultiPointOverlay':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: addMultiPointOverlay([])');
            }
        
            // handle the native call
            mGLMapView?.addMultiPointOverlay(com_amap_api_maps_model_MultiPointOverlayOptions()..refId = (args['var1'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::addMarker':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: addMarker([])');
            }
        
            // handle the native call
            mGLMapView?.addMarker(com_amap_api_maps_model_MarkerOptions()..refId = (args['var1'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::addMarkers':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: addMarkers([\'var2\':$args[var2]])');
            }
        
            // handle the native call
            mGLMapView?.addMarkers((args['var1'] as List).cast<int>().map((it) => com_amap_api_maps_model_MarkerOptions()..refId = it..tag = 'amap_map_fluttify').toList(), args['var2']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::addText':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: addText([])');
            }
        
            // handle the native call
            mGLMapView?.addText(com_amap_api_maps_model_TextOptions()..refId = (args['var1'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::addTileOverlay':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: addTileOverlay([])');
            }
        
            // handle the native call
            mGLMapView?.addTileOverlay(com_amap_api_maps_model_TileOverlayOptions()..refId = (args['var1'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::clear':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: clear([])');
            }
        
            // handle the native call
            mGLMapView?.clear();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::clear__bool':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: clear__bool([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.clear__bool(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getMapType':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getMapType([])');
            }
        
            // handle the native call
            mGLMapView?.getMapType();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setMapType':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setMapType([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setMapType(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::isTrafficEnabled':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: isTrafficEnabled([])');
            }
        
            // handle the native call
            mGLMapView?.isTrafficEnabled();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setTrafficEnabled':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setTrafficEnabled([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setTrafficEnabled(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::isIndoorEnabled':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: isIndoorEnabled([])');
            }
        
            // handle the native call
            mGLMapView?.isIndoorEnabled();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setIndoorEnabled':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setIndoorEnabled([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setIndoorEnabled(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::set3DBuildingEnabled':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: set3DBuildingEnabled([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.set3DBuildingEnabled(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::isMyLocationEnabled':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: isMyLocationEnabled([])');
            }
        
            // handle the native call
            mGLMapView?.isMyLocationEnabled();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setMyLocationEnabled':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setMyLocationEnabled([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setMyLocationEnabled(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setLoadOfflineData':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setLoadOfflineData([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setLoadOfflineData(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setMyLocationStyle':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setMyLocationStyle([])');
            }
        
            // handle the native call
            mGLMapView?.setMyLocationStyle(com_amap_api_maps_model_MyLocationStyle()..refId = (args['var1'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setMyLocationType':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setMyLocationType([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setMyLocationType(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getMapScreenMarkers':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getMapScreenMarkers([])');
            }
        
            // handle the native call
            mGLMapView?.getMapScreenMarkers();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setMapTextEnable':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setMapTextEnable([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setMapTextEnable(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setRoadArrowEnable':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setRoadArrowEnable([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setRoadArrowEnable(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setMyTrafficStyle':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setMyTrafficStyle([])');
            }
        
            // handle the native call
            mGLMapView?.setMyTrafficStyle(com_amap_api_maps_model_MyTrafficStyle()..refId = (args['var1'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getMyLocation':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getMyLocation([])');
            }
        
            // handle the native call
            mGLMapView?.getMyLocation();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setMyLocationRotateAngle':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setMyLocationRotateAngle([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setMyLocationRotateAngle(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getAMapUiSettings':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getAMapUiSettings([])');
            }
        
            // handle the native call
            mGLMapView?.getAMapUiSettings();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getAMapProjection':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getAMapProjection([])');
            }
        
            // handle the native call
            mGLMapView?.getAMapProjection();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getScalePerPixel':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getScalePerPixel([])');
            }
        
            // handle the native call
            mGLMapView?.getScalePerPixel();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setRunLowFrame':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setRunLowFrame([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setRunLowFrame(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::removecache':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: removecache([])');
            }
        
            // handle the native call
            mGLMapView?.removecache();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setCenterToPixel':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setCenterToPixel([\'var1\':$args[var1], \'var2\':$args[var2]])');
            }
        
            // handle the native call
            mGLMapView?.setCenterToPixel(args['var1'], args['var2']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setMapTextZIndex':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setMapTextZIndex([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setMapTextZIndex(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getMapTextZIndex':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getMapTextZIndex([])');
            }
        
            // handle the native call
            mGLMapView?.getMapTextZIndex();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::reloadMap':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: reloadMap([])');
            }
        
            // handle the native call
            mGLMapView?.reloadMap();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setRenderFps':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setRenderFps([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setRenderFps(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setIndoorBuildingInfo':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setIndoorBuildingInfo([])');
            }
        
            // handle the native call
            mGLMapView?.setIndoorBuildingInfo(com_amap_api_maps_model_IndoorBuildingInfo()..refId = (args['var1'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getZoomToSpanLevel':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getZoomToSpanLevel([])');
            }
        
            // handle the native call
            mGLMapView?.getZoomToSpanLevel(com_amap_api_maps_model_LatLng()..refId = (args['var1'])..tag = 'amap_map_fluttify', com_amap_api_maps_model_LatLng()..refId = (args['var2'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getInfoWindowAnimationManager':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getInfoWindowAnimationManager([])');
            }
        
            // handle the native call
            mGLMapView?.getInfoWindowAnimationManager();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setMaskLayerParams':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setMaskLayerParams([\'var1\':$args[var1], \'var2\':$args[var2], \'var3\':$args[var3], \'var4\':$args[var4], \'var5\':$args[var5], \'var6\':$args[var6]])');
            }
        
            // handle the native call
            mGLMapView?.setMaskLayerParams(args['var1'], args['var2'], args['var3'], args['var4'], args['var5'], args['var6']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setMaxZoomLevel':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setMaxZoomLevel([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setMaxZoomLevel(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setMinZoomLevel':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setMinZoomLevel([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setMinZoomLevel(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::resetMinMaxZoomPreference':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: resetMinMaxZoomPreference([])');
            }
        
            // handle the native call
            mGLMapView?.resetMinMaxZoomPreference();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setMapStatusLimits':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setMapStatusLimits([])');
            }
        
            // handle the native call
            mGLMapView?.setMapStatusLimits(com_amap_api_maps_model_LatLngBounds()..refId = (args['var1'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setCustomMapStylePath':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setCustomMapStylePath([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setCustomMapStylePath(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setMapCustomEnable':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setMapCustomEnable([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setMapCustomEnable(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::onChangeFinish':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: onChangeFinish([])');
            }
        
            // handle the native call
            mGLMapView?.onChangeFinish();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setZoomScaleParam':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setZoomScaleParam([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setZoomScaleParam(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::onFling':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: onFling([])');
            }
        
            // handle the native call
            mGLMapView?.onFling();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getMapWidth':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getMapWidth([])');
            }
        
            // handle the native call
            mGLMapView?.getMapWidth();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getMapHeight':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getMapHeight([])');
            }
        
            // handle the native call
            mGLMapView?.getMapHeight();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getCameraAngle':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getCameraAngle([])');
            }
        
            // handle the native call
            mGLMapView?.getCameraAngle();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getSkyHeight':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getSkyHeight([])');
            }
        
            // handle the native call
            mGLMapView?.getSkyHeight();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::isMaploaded':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: isMaploaded([])');
            }
        
            // handle the native call
            mGLMapView?.isMaploaded();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getMapConfig':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getMapConfig([])');
            }
        
            // handle the native call
            mGLMapView?.getMapConfig();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getView':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getView([])');
            }
        
            // handle the native call
            mGLMapView?.getView();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setZOrderOnTop':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setZOrderOnTop([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setZOrderOnTop(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::destroy':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: destroy([])');
            }
        
            // handle the native call
            mGLMapView?.destroy();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setVisibilityEx':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setVisibilityEx([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setVisibilityEx(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::onActivityPause':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: onActivityPause([])');
            }
        
            // handle the native call
            mGLMapView?.onActivityPause();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::onActivityResume':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: onActivityResume([])');
            }
        
            // handle the native call
            mGLMapView?.onActivityResume();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::createGLOverlay':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: createGLOverlay([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.createGLOverlay(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getGlOverlayMgrPtr':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getGlOverlayMgrPtr([])');
            }
        
            // handle the native call
            mGLMapView?.getGlOverlayMgrPtr();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::addCrossVector':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: addCrossVector([])');
            }
        
            // handle the native call
            mGLMapView?.addCrossVector(com_amap_api_maps_model_CrossOverlayOptions()..refId = (args['var1'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::addNaviRouteOverlay':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: addNaviRouteOverlay([])');
            }
        
            // handle the native call
            mGLMapView?.addNaviRouteOverlay();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getViewMatrix':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getViewMatrix([])');
            }
        
            // handle the native call
            mGLMapView?.getViewMatrix();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getProjectionMatrix':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getProjectionMatrix([])');
            }
        
            // handle the native call
            mGLMapView?.getProjectionMatrix();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::addOverlayTexture':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: addOverlayTexture([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.addOverlayTexture(args['var1'], com_autonavi_ae_gmap_gloverlay_GLTextureProperty()..refId = (args['var2'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::onTouchEvent':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: onTouchEvent([])');
            }
        
            // handle the native call
            mGLMapView?.onTouchEvent(android_view_MotionEvent()..refId = (args['var1'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::canStopMapRender':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: canStopMapRender([])');
            }
        
            // handle the native call
            mGLMapView?.canStopMapRender();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setCustomTextureResourcePath':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setCustomTextureResourcePath([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setCustomTextureResourcePath(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getMyLocationStyle':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getMyLocationStyle([])');
            }
        
            // handle the native call
            mGLMapView?.getMyLocationStyle();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getRenderMode':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getRenderMode([])');
            }
        
            // handle the native call
            mGLMapView?.getRenderMode();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::destroySurface':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: destroySurface([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.destroySurface(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::requestRender':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: requestRender([])');
            }
        
            // handle the native call
            mGLMapView?.requestRender();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::resetRenderTime':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: resetRenderTime([])');
            }
        
            // handle the native call
            mGLMapView?.resetRenderTime();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::onIndoorBuildingActivity':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: onIndoorBuildingActivity([\'var1\':$args[var1], \'var2\':$args[var2]])');
            }
        
            // handle the native call
            mGLMapView?.onIndoorBuildingActivity(args['var1'], args['var2']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getCamerInfo':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getCamerInfo([])');
            }
        
            // handle the native call
            mGLMapView?.getCamerInfo();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::checkMapState':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: checkMapState([])');
            }
        
            // handle the native call
            mGLMapView?.checkMapState(com_autonavi_ae_gmap_GLMapState()..refId = (args['var1'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setRenderMode':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setRenderMode([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setRenderMode(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getMapContentApprovalNumber':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getMapContentApprovalNumber([])');
            }
        
            // handle the native call
            mGLMapView?.getMapContentApprovalNumber();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::getSatelliteImageApprovalNumber':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: getSatelliteImageApprovalNumber([])');
            }
        
            // handle the native call
            mGLMapView?.getSatelliteImageApprovalNumber();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setMapLanguage':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setMapLanguage([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setMapLanguage(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setCustomMapStyleID':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setCustomMapStyleID([\'var1\':$args[var1]])');
            }
        
            // handle the native call
            mGLMapView?.setCustomMapStyleID(args['var1']);
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::addBuildingOverlay':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: addBuildingOverlay([])');
            }
        
            // handle the native call
            mGLMapView?.addBuildingOverlay();
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::addGLModel':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: addGLModel([])');
            }
        
            // handle the native call
            mGLMapView?.addGLModel(com_amap_api_maps_model_GL3DModelOptions()..refId = (args['var1'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::addParticleOverlay':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: addParticleOverlay([])');
            }
        
            // handle the native call
            mGLMapView?.addParticleOverlay(com_amap_api_maps_model_particle_ParticleOverlayOptions()..refId = (args['var1'])..tag = 'amap_map_fluttify');
            break;
          case 'Callback::com.autonavi.amap.mapcore.interfaces.IAMap::setCustomMapStyle':
            // print log
            if (fluttifyLogEnabled) {
              print('fluttify-dart-callback: setCustomMapStyle([])');
            }
        
            // handle the native call
            mGLMapView?.setCustomMapStyle(com_amap_api_maps_model_CustomMapStyleOptions()..refId = (args['var1'])..tag = 'amap_map_fluttify');
            break;
          default:
            break;
        }
      });
  }
  
  Future<void> set_mSurfacedestoryed(bool mSurfacedestoryed) async {
    await MethodChannel('me.yohom/amap_map_fluttify').invokeMethod('com.autonavi.ae.gmap.GLMapRender::set_mSurfacedestoryed', {'refId': refId, "mSurfacedestoryed": mSurfacedestoryed});
  
  
  }
  

  // generate methods
  Future<void> setTrafficMode(bool var1) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: com.autonavi.ae.gmap.GLMapRender@$refId::setTrafficMode([\'var1\':$var1])');
    }
  
    // invoke native method
    final result = await MethodChannel('me.yohom/amap_map_fluttify').invokeMethod('com.autonavi.ae.gmap.GLMapRender::setTrafficMode', {"var1": var1, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> resetTickCount(int var1) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: com.autonavi.ae.gmap.GLMapRender@$refId::resetTickCount([\'var1\':$var1])');
    }
  
    // invoke native method
    final result = await MethodChannel('me.yohom/amap_map_fluttify').invokeMethod('com.autonavi.ae.gmap.GLMapRender::resetTickCount', {"var1": var1, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<bool> isRenderPause() async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: com.autonavi.ae.gmap.GLMapRender@$refId::isRenderPause([])');
    }
  
    // invoke native method
    final result = await MethodChannel('me.yohom/amap_map_fluttify').invokeMethod('com.autonavi.ae.gmap.GLMapRender::isRenderPause', {"refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> setRenderFps(double var1) async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: com.autonavi.ae.gmap.GLMapRender@$refId::setRenderFps([\'var1\':$var1])');
    }
  
    // invoke native method
    final result = await MethodChannel('me.yohom/amap_map_fluttify').invokeMethod('com.autonavi.ae.gmap.GLMapRender::setRenderFps', {"var1": var1, "refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> renderPause() async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: com.autonavi.ae.gmap.GLMapRender@$refId::renderPause([])');
    }
  
    // invoke native method
    final result = await MethodChannel('me.yohom/amap_map_fluttify').invokeMethod('com.autonavi.ae.gmap.GLMapRender::renderPause', {"refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> renderResume() async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: com.autonavi.ae.gmap.GLMapRender@$refId::renderResume([])');
    }
  
    // invoke native method
    final result = await MethodChannel('me.yohom/amap_map_fluttify').invokeMethod('com.autonavi.ae.gmap.GLMapRender::renderResume', {"refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> onAttachedToWindow() async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: com.autonavi.ae.gmap.GLMapRender@$refId::onAttachedToWindow([])');
    }
  
    // invoke native method
    final result = await MethodChannel('me.yohom/amap_map_fluttify').invokeMethod('com.autonavi.ae.gmap.GLMapRender::onAttachedToWindow', {"refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> onDetachedFromWindow() async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: com.autonavi.ae.gmap.GLMapRender@$refId::onDetachedFromWindow([])');
    }
  
    // invoke native method
    final result = await MethodChannel('me.yohom/amap_map_fluttify').invokeMethod('com.autonavi.ae.gmap.GLMapRender::onDetachedFromWindow', {"refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
  Future<void> onSurfaceDestory() async {
    // print log
    if (fluttifyLogEnabled) {
      print('fluttify-dart: com.autonavi.ae.gmap.GLMapRender@$refId::onSurfaceDestory([])');
    }
  
    // invoke native method
    final result = await MethodChannel('me.yohom/amap_map_fluttify').invokeMethod('com.autonavi.ae.gmap.GLMapRender::onSurfaceDestory', {"refId": refId});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (result == null) {
      return null;
    } else {
    
      return result;
    }
  }
  
}